<main class="material">
  <h1>
    Удаление невидимых поверхностей - Z-Буфер
  </h1>
  <p>
    Z-буферизация — в компьютерной трёхмерной графике способ учёта удалённости элемента изображения. Представляет собой один из вариантов решения «проблемы видимости». Очень эффективен и практически не имеет недостатков, если реализуется аппаратно. Программно же существуют другие методы, способные конкурировать с ним: Z-сортировка («алгоритм художника») и двоичное разбиение пространства (BSP), но они также имеют свои достоинства и недостатки. Основной недостаток Z-буферизации состоит в потреблении большого объёма памяти: в работе используется так называемый буфер глубины или Z-буфер.
  </p>
  <app-image link="/assets/img/zbuffer_1.png" desc="Рисунок 3.1 - Карта глубины"></app-image>
  <p>
    Z-буфер представляет собой двумерный массив, каждый элемент которого соответствует пикселю на экране. Когда видеокарта рисует пиксель, его удалённость просчитывается и записывается в ячейку Z-буфера. Если пиксели двух рисуемых объектов перекрываются, то их значения глубины сравниваются, и рисуется тот, который ближе, а его значение удалённости сохраняется в буфер. Получаемое при этом графическое изображение носит название z-depth карта или карта глубины, представляющая собой полутоновое графическое изображение, каждый пиксель которого может принимать до 256 значений серого. По ним определяется удалённость от зрителя того или иного объекта трехмерной сцены. Карта широко применяется в постобработке для придания объёмности и реалистичности и создаёт такие эффекты, как глубина резкости, атмосферная дымка и т. д. Также карта используется в 3д-пакетах для текстурирования, делая поверхность рельефной.
  </p>
  <p>
    Разрядность буфера глубины оказывает сильное влияние на качество визуализации: использование 16-битного буфера может привести к геометрическим искажениям, например, эффекту «борьбы», если два объекта находятся близко друг к другу. 24, 32-разрядные буферы хорошо справляются со своей задачей. 8-битные почти никогда не используются из-за низкой точности.
  </p>
  <h2>
    Разбор алгоритма
  </h2>
  <p>
    Давайте представим себе простейшую сцену из трёх треугольников, камера смотрит сверху вниз, мы проецируем наши треугольники на белый экран:
  </p>
  <app-image link="/assets/img/zbuffer_2.png" desc="Рисунок 3.2 - Пример сцены"></app-image>
  <app-image link="/assets/img/zbuffer_3.png" desc="Рисунок 3.3 - Рендер сцены"></app-image>
  <p>
    Возникает вопрос, где находится синяя грань, за красной или перед ней? Например, <a href="https://ru.wikipedia.org/wiki/Алгоритм_художника">алгоритм художника</a> здесь сломается. Cинюю грань можно разбить на две, одна часть перед красной, другая за. А та, что перед красной, ещё на две — перед зелёной и за зелёной. Достаточно ясно, что в сценах с миллионами треугольников это быстро становится непростой задачей. У неё есть решения, например, пользоваться <a href="https://ru.wikipedia.org/wiki/Двоичное_разбиение_пространства">Двоичными разбиениями пространства</a>, заодно это помогает и для сортировки при смене положения камеры, но давайте использовать что-то простое.
  </p>
  <p>
    Давайте отбросим одно из измерений и рассмотрим двумерную сцену. Так как сцена двумерная то её очень просто нарисовать с помощью трёх вызовов функции line() которую мы создали ранее.
  </p>
  <pre><code [languages]="['c++']" [highlight]="code1"></code></pre>
  <app-image link="/assets/img/3_4.png" desc="Рисунок 3.4 - Двумерная сцена"></app-image>
  <p>
    Наша задача отобразить эти отрезки так, как если бы мы смотрели на них сверху в низ. Рендер должен быть на 100% ширину и 20 пикселей в высоту. Рассмотрим код представляющий из себя реализацию Y - буфера:
  </p>
  <pre><code [languages]="['c++']" [highlight]="code2"></code></pre>
  <p>Мы создаём массив yBuffer размером равным ширине выходного изображения, и инициализируем минимальными значениями. Рассмотрим функцию <b>rasterize()</b>:</p>
  <pre><code [languages]="['c++']" [highlight]="code3"></code></pre>
  <p>Мы проходим по всем x-координатам между p0.x и p1.x и вычисляем соответствующую y-координату нашей линии. Затем проверяем массив yBuffer по этой координате x. Если текущий пиксель ближе к камере, нежели то, что там сохранено, то мы его рисуем в картинке, и ставим новую y-координату в буфер. Теперь попрядку рассмотрим каждый вызов функции <b>rasterize()</b></p>
  <h3>Первый вызов функции <b>rasterize</b>:</h3>
  <app-image link="/assets/img/3_5.png" desc="Рисунок 3.5 - Содержимое экрана"></app-image>
  <app-image link="/assets/img/3_6.png" desc="Рисунок 3.6 - Содержимое Y-буфера"></app-image>
  <h3>Второй вызов функции <b>rasterize</b>:</h3>
  <app-image link="/assets/img/3_7.png" desc="Рисунок 3.7 - Содержимое экрана"></app-image>
  <app-image link="/assets/img/3_8.png" desc="Рисунок 3.8 - Содержимое Y-буфера"></app-image>
  <h3>Третий вызов функции <b>rasterize</b>:</h3>
  <app-image link="/assets/img/3_9.png" desc="Рисунок 3.9 - Содержимое экрана"></app-image>
  <app-image link="/assets/img/3_10.png" desc="Рисунок 3.10 - Содержимое Y-буфера"></app-image>
  <h2 class="task">Задание</h2>
  <h3>Используя материалы данной главы необходимо реализовать Z-буфер преобразовав функцию rasterize.</h3>
  <app-image link="/assets/img/3_11.png" desc="Рисунок 3.11 - Пример выполненного задания"></app-image>
</main>
