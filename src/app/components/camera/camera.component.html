<main class="material">
  <h1>
    Движение камеры
  </h1>
  <p>
    Для начала нужно разобраться как произвести замену базиса в треёхмерном пространстве. В евклидовом пространстве система координат задаётся точкой отсчёта и базисом пространства. Что означает, что в системе координат (O, i,j,k) точка P имеет координаты (x,y,z). Это означает, что вектор OP задаётся следующим образом:
  </p>
  <app-image link="/assets/img/camera/5_1.png" desc="Рисунок 5.1 - Вектор OP"></app-image>
  <p>Теперь представим, что у нас есть вторая система координат (O',i',j',k'). Как нам преобразовать координаты точки, из одной системы в другую? Для начала заметим, что, так как (i,j,k) и (i',j',k') — это базисы, то существует невырожденная матрица М, такая что:</p>
  <app-image link="/assets/img/camera/5_2.png" desc="Рисунок 5.2"></app-image>
  <app-image link="/assets/img/camera/5_3.png" desc="Рисунок 5.3 - Наглядное представление"></app-image>
  <p>Распишем представление вектора OP:</p>
  <app-image link="/assets/img/camera/5_4.png" desc="Рисунок 5.4"></app-image>
  <p>Подставим во вторую часть выражение замены базиса:</p>
  <app-image link="/assets/img/camera/5_5.png" desc="Рисунок 5.5"></app-image>
  <p>И это нам даст формулу замены координат для двух базисов:</p>
  <app-image link="/assets/img/camera/5_6.png" desc="Рисунок 5.6"></app-image>
  <p>То есть если нам нужно подвинуть камеру мы просто подвинем всю сцену, оставив камеру неподвижной. Давайте поставим задачу следующим образом: мы хотим сделать так, чтобы камера находилась в точке e (eye), смотрела в точку c (center) и чтобы заданный вектор u (up) в нашей финальной картинке был бы вертикален.</p>
  <app-image link="/assets/img/camera/5_7.png" desc="Рисунок 5.7"></app-image>
  <p>Это означает, что мы делаем рендер в системе (c, x'y'z'). Но модель задана в системе (O, xyz), значит, нам нужно посчитать x'y'z' и соответствующую матрицу перехода. Вот код, который возвращает нужную нам матрицу:</p>
  <pre><code [languages]="['c++']" [highlight]="code1"></code></pre>
  <p>Начнём с того, что z' — это просто вектор ce (не забудем его нормализовать, так проще работать). Как посчитать x'? Просто векторным произведением между u и z'. Затем считаем y', который будет ортогонален уже посчитанным x' и z' (по условию задачи вектор ce и u не обязательно ортогональны). Далее делаем параллельный перенос в c, и наша матрица пересчёта координат готова. Достаточно взять любую точку с координатами (x,y,z,1) в старом базисе, умножить её на эту матрицу, и мы получим координаты в новом базисе.</p>
  <h3>Цепь преобразований</h3>
  <p>Модели (например, пресонажи) сделаны в своей локальной системе координат. Они вставляются в сцену, которая выражена в мировых координатах. Переход от одних к другим осуществляется матрицей Model. Дальше, мы хотим выразить это в систему координат камеры, матрица перехода от мировых к камере называется View. Затем, мы осуществляем перспективное искажение при помощи матрицы Projection из предыдущей главы, она переводит сцену в так называемые clip coordinates. Ну и затем мы отображаем это всё на экране, матрица прехода к экранным координатам это Viewport.</p>
  <p>То есть, если мы прочитали точку вершину из файла, то чтобы показать её на экране, мы проделываем умножение:</p>
  <pre><code [languages]="['c++']" [highlight]="code2"></code></pre>
  <h3>Преобразование нормальных векторов</h3>
  <p>Если у нас задана модель и уже посчитаны (или, например, заданы руками) нормальные вектора к этой модели, и эта модель подвергается преобразованию M, то нормальные вектора подвергаются преобразованию, обратному к транспонированному M.</p>
  <p>Рассмотрим треугольник и вектор <b>a</b>, являющийся нормальным к его наклонной грани. Если мы просто растянем наше пространство в два раза по вертикали, то преобразованный вектор <b>a</b> перестанет быть нормальным к преобразованной грани.
  </p>
  <p>У нас есть вектор нормали <b>a</b>=(A,B,C). Мы знаем, что плоскость, проходящая через начало координат, и имеющая нормалью вектор <b>a</b> (на нашей иллюстрации это наклонное ребро левого треугольника), задаётся уравнением Ax+By+Cz=0. Давайте запишем это уравнение в матричном виде, причём сразу в однородных координатах:</p>
  <app-image link="/assets/img/camera/5_8.png" desc="Рисунок 5.8"></app-image>
  <p>(A,B,C) — это вектор, поэтому получает ноль в последнюю компоненту при погружении в четырёхмерное пространство, <b>a</b> (x,y,z) — это точка, поэтому к нему приписываем 1.</p>
  <p>Давайте добавим единичную матрицу (М, умноженная на обратную к ней) в середину этой записи:</p>
  <app-image link="/assets/img/camera/5_10.png" desc="Рисунок 5.10"></app-image>
  <p>Выражение в правых скобках — это преобразованные точки. В левых — нормальный вектор. Так как в стандартной конвенции при линейном отображении мы записываем векторы (и точки) в столбец, то предыдущее выражение может быть записано следующим образом:</p>
  <app-image link="/assets/img/camera/5_11.png" desc="Рисунок 5.11"></app-image>
  <p>Что ровно приводит нас к вышеозначенному факту, что нормаль к преобразованному объекту получается преобразованием исходной нормали, обратным к транспонированному M. Заметьте, если M — это композиция параллельных переносов, вращений и однородных растягиваний, то транспонированная М равняется обратной М, и они друг друга аннулируют. Но так как наши матрицы преобразований будут включать в себя перспективное искажение, это нам мало поможет.</p>
  <h2 class="task">Задание</h2>
  <h3>Используя материалы данной главы необходимо создать несколько изображений на которых модель будет представлена с разных ракурсов с помощью движения камеры.</h3>
  <app-image link="/assets/img/camera/5_12.png" desc="Рисунок 5.12 - Пример выполненного задания"></app-image>
</main>
