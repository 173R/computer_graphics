<main class="material">
  <h1>
    Построение перспективного искажения
  </h1>
  <p>
    В данной главе мы разберёмся как создавать перспективное искажение.
  </p>
  <h3>
    Линейные преобразования плоскости
  </h3>
  <p>Линейное преобразование на плоскости отображение задаётся соответствующей матрицей. Если мы возьмём точку (x,y), то её преобразование записывается следующим образом:</p>
  <app-image link="/assets/img/perspective/4_1.png" desc="Рисунок 4.1 - Линейное преобразование"></app-image>
  <p>Самое простое преобразование задаётся единичной матрицей, оно просто оставляет каждую точку на месте</p>
  <app-image link="/assets/img/perspective/4_2.png" desc="Рисунок 4.2 - Простейшее преобразование"></app-image>
  <p>Коэффициенты на диагонали матрицы задают растягивание/сжатие плоскости. Давайте проиллюстрируем картинкой: например, если мы запишем следующее преобразование:</p>
  <app-image link="/assets/img/perspective/4_3.png" desc="Рисунок 4.3"></app-image>
  <p>То белый объект преобразуется в жёлтый. Красный и зелёный отрезки дают единичные векторы по оси x и y, соответственно.</p>
  <app-image link="/assets/img/perspective/4_4.png" desc="Рисунок 4.4"></app-image>
  <p>Зачем вообще использовать матрицы? Начнём с того, что в матричной форме преобразование всего объекта можно записать вот таким образом:</p>
  <app-image link="/assets/img/perspective/4_5.png" desc="Рисунок 4.5"></app-image>
  <p>
    Здесь преобразование то же, что и в предыдущем примере, а вот матрица в две строки и пять столбцов не что иное, как массив координат нашего куба. Мы просто взяли целиком массив, умножили на преобразование, и получили уже преобразованный объект.
  </p>
  <p>Крайне регулярно мы хотим, чтобы объект подвергся нескольким преобразованиями подряд. Представьте, что вы пишете в вашем коде функции преобразований типа:</p>
  <pre><code [languages]="['c++']" [highlight]="code1"></code></pre>
  <p>Этот код делает два линейных преобразования на каждую вершину объекта, а они исчисляются в миллионах. И преобразований зачастую мы хотим очень много. А с матричным подходом мы перемножаем все матрицы преобразования и умножаем на наш объект один раз.</p>
  <p>Мы знаем, что диагональные элементы нам дают масштабирование по осям. За что отвечают два других коэффициента матрицы? Давайте рассмотрим такое преобразование:</p>
  <app-image link="/assets/img/perspective/4_6.png" desc="Рисунок 4.6"></app-image>
  <p>
    Не что иное, как простой сдвиг вдоль оси x. Второй анти-диагональный элемент даст сдвиг вдоль оси y. Таким образом, базовых линейных преобразований на плоскости только два: растягивание по осям и сдвиг вдоль оси.
  </p>
  <p>Вращение может быть представлено как композиция трёх сдвигов, здесь белый объект преобразован сначала в красный, затем в зелёный, затем в синий:</p>
  <app-image link="/assets/img/perspective/4_7.png" desc="Рисунок 4.7"></app-image>
  <p>Матрица вращения против часовой стрелки вокруг начала координат может быть записана напрямую:</p>
  <app-image link="/assets/img/perspective/4_8.png" desc="Рисунок 4.8"></app-image>
  <h3>Cоставные преобразования</h3>
  <p>Предположим, вам нужно повернуть плоский объект вокруг точки (x0, y0). Как это сделать? Мы умеем вращать вокруг центра координат, мы умеем сдвигать. Сдвигаем x0,y0 в центр координат, вращаем, возвращаем назад.</p>
  <app-image link="/assets/img/perspective/4_9.png" desc="Рисунок 4.9"></app-image>
  <p>В 3д последовательности действий будут немного длиннее, но смысл остаётся прежним: нам достаточно уметь делать несколько базовых преобразований.</p>
  <p>Применим преобразование (Рисунок 4.10) к нашему стандартному тестовому объекту. Тестовый объект белый, единичные X и Y вектора показаны красным и зелёным, соответственно</p>
  <app-image link="/assets/img/perspective/4_10.png" desc="Рисунок 4.10"></app-image>
  <app-image link="/assets/img/perspective/4_11.png" desc="Рисунок 4.11"></app-image>
  <app-image link="/assets/img/perspective/4_12.png" desc="Рисунок 4.12 - Преобразованный объект"></app-image>
  <p>Теперь мы будем проецировать наш двумерный объект на прямую x=0. Причём теперь усложним задачу: проекция будет центральной, наша камера находится в точке (5, 0) и смотрит в начало координат. Чтобы найти проекцию, мы должны провести прямые, проходящие через точку камеры и каждую вершину нашего объекта (жёлтые прямые), а затем найти их пересечение с прямой экрана (белая вертикальная).</p>
  <app-image link="/assets/img/perspective/4_13.png" desc="Рисунок 4.13"></app-image>
  <p>А теперь давайте уберём оригинальный объект и вместо него нарисуем трансформированный.</p>
  <app-image link="/assets/img/perspective/4_14.png" desc="Рисунок 4.14"></app-image>
  <p>Если мы используем обычную ортогональную проекцию нашего трансформированного объекта, то мы найдём ровно те же самые точки.
    Ведь что делает это отображение? Оно каждое вертикальное ребро оставляет вертикальным, но при этом растягивает те, которые близко к камере, и сжимает те, что дальше от камеры. Правильно подобрав коэффициент растяжения-сжатия мы можем как раз достичь эффекта, что простой ортогональной проекцией мы получаем изображение в перспективном искажении.</p>
  <h2 class="task">Задание</h2>
  <h3>Используя материалы данной главы необходимо создать изображение с перспективным искажением в трёхмерном пространстве.</h3>
  <app-image link="/assets/img/perspective/4_15.png" desc="Рисунок 4.15 - Пример выполненного задания"></app-image>
</main>
